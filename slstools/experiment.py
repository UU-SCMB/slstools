import numpy as np
import os
from pathlib import Path


class Experiment:
    """Helper class for data generated by the SCM SLS setup.

    *For example usage, see [`Fit` class](#slstools.Fit).*

    Attributes
    ----------
    filepath : pathlib.Path
        Path object of the file containing the SLS data
    data : numpy.ndarray
        Numpy array containing all raw data from the file.
    theta : numpy.ndarray
        Numpy array containing the scattering angles in degrees.
    intensity_uncor : numpy.ndarray
        Numpy array containing scattering intensities, not corrected for
        scattering volume (perpendicular polarisation).
    intensity : numpy.ndarray
        Numpy array containing scattering intensities, corrected for scattering
        volume (perpendicular polarisation).
    K : numpy.ndarray
        Numpy array containing the scattering angles (in units of `K_unit`).
    K_unit : str
        (inverse) unit of K, one of [`nm`, `µm`, `m`].
    temperature : numpy.ndarray
        Numpy array containing temperatures that were measured by the setup.
    """

    def __init__(
        self,
        filename,
        normalise=True,
        K_unit="m",
        remove_data_after_pole=True,
        **kwargs,
    ):
        """Initialisation of the class, assigns the data as class variables.

        Parameters
        ----------
        filename : str
            Path to file
        normalise : bool, optional
            Whether or not to normalise the intensity data to 1. The default is
            True.
        K_unit : str, optional
            Inverse units of K, one of [`nm`, `µm`, `m`]. E.g. if `nm` is given
            a `K_unit`, `K` will be given in units of. The default is `m`.
        """

        if not os.path.exists(filename):
            raise FileNotFoundError(f"The file {filename} does not exist")

        if K_unit not in ["m", "nm", "um", "µm"]:
            raise ValueError(
                f"The unit of K should be m, nm or µm. The given value '{K_unit}' is not allowed."
            )

        self.filepath = Path(filename)

        # cols=['theta', 'I', 'Icor', 'K', 'T'])
        self.data = np.genfromtxt(filename, delimiter=",", skip_header=3, **kwargs).T
        self.remove_data_after_pole = remove_data_after_pole

        if self.remove_data_after_pole:
            self.data = self.data[:, (self.data[0] < 126.0) | (self.data[0] > 131.0)]
        self.theta = self.data[0]
        # not corrected for scattering volume
        self.intensity_uncor = self.data[1]
        self.intensity = self.data[2]

        if normalise:
            self.intensity /= self.intensity.max()
            self.intensity_uncor /= self.intensity_uncor.max()

        self.K = self.data[3]
        self.K_unit = K_unit

        if self.K_unit == "nm":
            self.K /= 1e9
        elif self.K_unit == "um" or self.K_unit == "µm":
            self.K_unit = "µm"
            self.K /= 1e6

        self.temperature = self.data[4]

    def recalculate_K(self, n_m=1.333, wavelength=632.8):
        """Recalculate the `K` attribute of the instance,
        using the new medium refractive index and laser
        wavelength

        Parameters
        ----------
        n_m : `float` or `complex`, optional
            Refractive index of the medium, by default 1.333.
        wavelength : `float`, optional
            Vacuum wavelength of the laser in `nm`, by default 632.8.
        """
        self.K = (
            4
            * np.pi
            * n_m
            / (wavelength * 1e-9)
            * np.sin(self.theta / 2.0 * np.pi / 180)
        )

        if self.K_unit == "nm":
            self.K /= 1e9
        elif self.K_unit == "um" or self.K_unit == "µm":
            self.K_unit = "µm"
            self.K /= 1e6

    def correct_for_reflection(self, n_m=1.333, n_glass=1.49):
        """Correct the intensity for reflection

        Stores the corrected intensity as `intensity` atrribute of the class,
        to allow for easier fitting. The old intensities are now stored in the
        `intensity_reflection_uncor` attribute.

        Due to reflections, we need to correct the measured intensity for
        reflection at the glass-air interface of the toluene vessel as follows:

        $$I_{cor}(\\theta) = I_m(\\theta)-R*I_m(\\pi - \\theta)$$

        with

        * \\(I_m(\\theta)\\) the measured intensity at a certain angle \\(\\theta\\)
        * \\(R = \\left( \\frac{n_{glass} - n_{air}}{n_{glass}+ n_{air}} \\right)^2 +\\left( \\frac{n_{glass} - n_{solvent}}{n_{glass}+ n_{solvent}} \\right)^2\\)
        * \\( n_{air} = 1.00\\), \\(n_{glass}=\\) `n_glass` , \\(n_{solvent}= \\) `n_m`

        Parameters
        ----------
        n_m : `float`, optional
            Refractive index of the medium, by default 1.333 (water).
        n_glass : `float`, optional
            Refractive index of the glass, by default 1.49.
        """
        R = ((n_glass - 1.0) / (n_glass + 1.0)) ** 2 + (
            (n_glass - n_m) / (n_glass + n_m)
        ) ** 2

        refl_theta = 180.0 - self.theta
        self.reflection_intensity = np.array(
            [
                self.intensity[self.theta == t][0] if t in self.theta else 0.0
                for t in refl_theta
            ]
        )
        # find intensities of theta=refl_theta, else set to 0.

        self.intensity_reflection_uncor = self.intensity
        self.intensity = self.intensity_reflection_uncor - R * self.reflection_intensity
